if (!("a" in window)) {
    var a = 1;
}

alert(a); // значение переменной "a" будет равно "undefined" потому, что условие "!("a" in window)" будет false даже при том, что такого свойства "a" изначально в объекте window нет. При обходе объекта window оператором in в нем автоматически создается свойство, которое мы проверяем на вхождение.


var b = function a(x) {
    x && a(--x);
};
alert(a); // результат будет - a is not defined потому, что функция "a" определена локально в качестве значения переменной "b" и вызываться может только внутри переменной "b".


function a(x) {
    return x * 2;
}
var a;
alert(a); // будет показан вызов функции "a", а не переменной "a" потому, что переменной "a" не присвоено значение (свободная переменная), а значит и не создана ссылка на нее.


function b(x, y, a) {
    arguments[2] = 10;
    alert(a);
}
b(1, 2, 3); // в режиме "use strict" результат будет - 3 потому, что в новой версии JS переопределение аргументов функции через arguments действует в локальной области видимости этой функции. Без режима "use strict" результат будет - 10 потому, что аргументы не будут делиться на локальные и глобальные и поменяются те, которые пришли в функцию.


function a() {
    alert(this);
}
a.call(null); // в режиме "use strict" результат - null, в режиме без "use sctrict" результат - объект window, согласно стандарту ECMA-262. 
